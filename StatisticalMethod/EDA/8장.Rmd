---
title: "통계 방법론Ⅱ - 탐색적 데이터 분석"
author: "응용통계학과 이준혁"
date: "2023-06-10(토)"
output:
  html_document:
    css: styles.css
    #code_folding: show
    fig_caption: yes
    fig_height: 7.5
    fig_width: 10
    fig_retina: null
    highlight: haddock
    self_contained: yes
    theme: cosmo
    toc: yes
    toc_depth: 6
    toc_float: yes
    fig_dpi: 300
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<style type="text/css">
  body, td {
     font-size: 16px;
     font-family: 맑은 고딕
  }
  code.r{
    font-size: 16px;
    font-weight: bold;
    font-family: 맑은 고딕
  }
  pre {
    font-size: 14px
    font-family: 맑은 고딕
  }
  h1,h2,h3,h4,h5,h6{
    font-family: 맑은 고딕;
    font-weight: bold;
  }
  h1{
    font-size: 18pt;
  }
  h2{
    font-size: 16pt;
  }
  h3{
    font-size: 14pt;
  }
</style>

<br><br><br><br>

---

# Ch8. 저항선과 강건 회귀(Resistance Line & Robust Regression)

## 8.1. 저항선 Resistance Line

-   3-요약점(3-summary point)과 잔차(residuals)를 이용한 반복 적합과 교정을 통하여 이상점들의 영향을 덜 받는 직선식을 추정하는 방법이다.
-   회귀 분석이 평균으로 계산하니까 이상점에 민감하다.
    - 이를 극복하기 위한 방법 중 하나이다.

### 8.1.1. diamonds 중에서 일부 데이터(jset.csv)

#### 8.1.1.1. 데이터 불러오기
```{r}
jset <- read.csv(paste0(data_path, "jset.csv"))
```

#### 8.1.1.2. 데이터 구조 확인
```{r}
na_count(jset)
```
```{r}
jset %>% 
  ggplot(aes(carat, s.price)) +
  geom_point(color = sbl) +
  theme_bw()
```

#### 8.1.1.3. 저항선의 적합(1차)
```{r}
first <- rline(s.price ~ carat, jset, iter = 1)

jset %>% 
  ggplot(aes(carat, s.price)) +
  geom_point(color = "#383838") +
  geom_abline(intercept = first$a - first$b * first$xC,
              slope = first$b,
              color = ldg
              ) +
  labs(subtitle = "저항성 적합(1차)의 결과") +
  theme_bw()
```
#### 8.1.1.4. 저항선의 반복 적합
```{r}
#초기화
out <- data.frame(Iteration = NULL, Slope = NULL, Intercept = NULL)
iter.limit <- 10
#반복
for(iterations in 1:iter.limit){
  rfit <- rline(s.price ~ carat, jset, iter = iterations)
  out <- rbind(out,
               data.frame(Iteration = iterations,
                          Slope = rfit$b,
                          Intercept = rfit$a)
  )
}
#결과
out
```
#### 8.1.1.5. iter = 6

-   6번째 반복 이후의 **[절편(55.62368)]{style="color: red;"}**, **[기울기(44.65532)]{style="color: red;"}**로 수렴한다.
    -   따라서, iter = 6으로 최종 저항선을 추정한다.
```{r}
final <- rline(s.price ~ carat, jset, iter = 6)
jset$res <- final$residual
#
j1 <- jset %>% 
  ggplot(aes(carat, s.price)) +
  geom_point(color = sbl) +
  geom_abline(intercept = first$a - first$b*first$xC,
              slope = first$b,
              color = ldg) +
  geom_abline(intercept = final$a - final$b*final$xC,
              slope = final$b,
              color = lre) +
  labs(subtitle = "1차(gray)/최종(red) 저항선 적합 결과") +
  theme_bw()

j2 <- jset %>% 
  ggplot(aes(carat, res)) +
  geom_point(color = sbl) +
  geom_hline(yintercept = 0,
             color = lre) +
  labs(subtitle = "최종(red) 적합의 잔차", y = "잔차") +
  theme_bw()

grid.arrange(j1, j2, ncol = 2)
```
```{r}
jset %>% 
  dplyr::filter(res <= -25) %>% 
    dplyr::select(clarity, carat, table, s.price)
```

## 8.2 강건 선형 회귀 Robust Linear Regression

-   선형 회귀 분석은 오차에 가정되는 확률 분포의 타당성 여부와 이상점의 영향을 많이 받는다는 단점을 갖는다.
    -   이러한 단점을 보완할 수 있는 방법으로 다음의 강건(rubust) 선형 회귀 분석이 소개되었다.
        -   최소 중앙값 제곱
        -   최소 절사 제곱
        -   후버의 M추정
        
### 8.2.1. simple 데이터 실습(simple.csv)

```{r}
#데이터 로드
simple <- read_csv(paste0(data_path, "simple.csv"),show_col_types = FALSE)
str(simple)
#결측값 개수 확인
sum(is.na(simple))
na_count(simple)
```

```{r}
#산점도로 데이터 파악
simple %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(color = "black") +
  theme_bw()
```
-   단순 회귀 분석 적합
```{r}
fit.lin <- lm(y ~ x, simple)
summary(fit.lin)
```
-   다항 회귀 분석 적합

```{r}
fit.poly <- lm(y ~ x + I(x^2), simple)
summary(fit.poly)
```

-    산점도 비교(단순회귀분석 Vs 다항회귀분석)
    -   단순 회귀 모형은 데이터의 패턴을 찾지 못한다.
    -   다항 회귀 식은 오른쪽에 위치한 이상치에 민감하게 반응한다.

```{r}
colors <- c("linear" = sbl, "quadratic" = lre)
simple %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(color = "black") +
  stat_smooth(aes(x, fit.lin$fitted.values, color = "linear")) +
  stat_smooth(aes(x, fit.poly$fitted.values, color = "quadratic"), linetype="dashed") +
  labs(color = "Fits", subtitle = "단순/다항 회귀 적합 결과") +
  theme_bw() +
  scale_color_manual(values = colors)
```


-   최소 중앙값 제곱(LMS, Least Median of Squares) 적용하기
    -   R의 `MASS` 패키지 내에 있는 **[lqs(method = "lms")]{style="color: blue;"}**
```{r}
lms <- MASS::lqs(y ~ x, method = "lms", data = simple)
lms
```

-   산점도 비교

```{r}
colors <- c("ls" = sbl, "lms" = lre)
simple %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(color = "black") +
  stat_smooth(aes(x, fit.lin$fitted.values, color = "ls")) +
  stat_smooth(aes(x, lms$fitted.values, color = "lms")) +
  labs(color = "Fits", subtitle = "단순/LMS 회귀 적합 결과") +
  theme_bw() +
  scale_color_manual(values = colors)
```


-   최소 절사 제곱(LTS, Least Trimmed Squares)은 R의의 `MASS` 패키지 내에 있는 **[lqs(method = "lts")]{style="color: blue;"}** 함수

```{r}
lts <- MASS::lqs(y ~ x, method = "lts", data = simple)
lts
```

-   단순/LMS/LTS 회귀 적합 결과 산점도 비교

```{r}
colors <- c("ls" = sbl, "lms" = lre, "lts" = ngr)
simple %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(color = "black") +
  stat_smooth(aes(x, fit.lin$fitted.values, color = "ls")) +
  stat_smooth(aes(x, lms$fitted.values, color = "lms")) +
  stat_smooth(aes(x, lts$fitted.values, color = "lts")) +
  labs(color = "Fits", subtitle = "단순/LMS/LTS 회귀 적합 결과") +
  theme_bw() +
  scale_color_manual(values = colors)
```


### 8.2.2. phonecall 데이터(phonecall.csv)

-   후버의 M 추정 - M-estimation은 R의의 `MASS` 패키지 내에 있는 **[rlm(psi = psi.huber)]{style="color: blue;"}** 함수


```{r}
#데이터 로드
phonecall <- read_csv(paste0(data_path, "phonecall.csv"),show_col_types = FALSE)
str(phonecall) #2개 변수
#결측값 개수 확인
sum(is.na(phonecall))
na_count(phonecall)

rlm <- MASS::rlm(calls ~ year, phonecall, psi = psi.huber, maxit = 50)
rlm

```

-   단순/LMS/LTS/RLM 회귀 적합 결과 산점도 비교

```{r}

lin <- lm(calls ~ year, phonecall)
plms <- MASS::lqs(calls ~ year, method = "lms", data = phonecall)
plts <- MASS::lqs(calls ~ year, method = "lts", data = phonecall)

colors <- c("ls" = sbl, "lms" = lre, "lts" = ngr, "rlm" = "orange")
phonecall %>%
  ggplot(aes(x = year, y = calls)) +
  geom_point(color = sbl) +
  stat_smooth(aes(year, lin$fitted.values, color = "ls")) +
  stat_smooth(aes(year, plms$fitted.values, color = "lms")) +
  stat_smooth(aes(year, plts$fitted.values, color = "lts")) +
  stat_smooth(aes(year, rlm$fitted.values, color = "rlm")) +
  labs(color = "Fits", subtitle = "단순/LMS/LTS/RLM 회귀 적합 결과") +
  theme_bw() +
  scale_color_manual(values = colors)
```

### 8.2.3. diamonds 데이터

```{r}
#데이터로드
data(diamonds)
jset <- diamonds %>%
  dplyr::filter(color == "J") %>%
  dplyr::filter(cut == "Fair")
str(jset)

set <- jset %>%
  mutate(s.price = sqrt(price))
```


-   산점도 파악
```{r}
colors <- c("ls" = sbl, "lms" = lre, "lts" = ngr, "rlm" = "orange")
set$lin <- lm(s.price ~ carat, set)$fitted.value
set$rlm <- rlm(s.price ~ carat, set, psi = psi.huber, maxit = 50)$fitted.value
set$lms <- lqs(s.price ~ carat, method = "lms", data = set)$fitted.value
set$lts <- lqs(s.price ~ carat, method = "lts", data = set)$fitted.value

set %>%
  ggplot(aes(x = carat, y = s.price)) +
  geom_point(color = sbl) +
  stat_smooth(aes(carat, lin, color = "ls")) +
  stat_smooth(aes(carat, lms, color = "lms")) +
  stat_smooth(aes(carat, lts, color = "lts")) +
  stat_smooth(aes(carat, rlm, color = "rlm")) +
  labs(color = "Fits", subtitle = "단순/LMS/LTS/RLM 회귀 적합 결과") +
  theme_bw() +
  scale_color_manual(values = colors)

```

## 8.3 스플라인스 선형 회귀 Splines Linear Regression

-   설명 변수의 범위 별로 서로 다른 함수적 관계가 존재하는 경우, 적절한 범위를 구분하여 너트(knot)를 정의하고 이 모형을 고려할 수 있다.

### qmr 데이터(qmr.csv)

-   00전자의 SW사업부에서의 QM 검증 결과의 타당성을 확인하고 QMR Score와의 관계를 분석하기 위하여 24개의 제품(자사, 경쟁사)을 조사하였다. 적절한 모형이 도출된다면, 이를 이용하여 SW 초기 완성도 판단을 위한 검토 기준으로 활용하고자 한다.

```{r}
#데이터 로드
qm <- read_csv(paste0(data_path, "qmr.csv"), show_col_types = FALSE)
str(qm)
#결측값 개수 확인
sum(is.na(qm))
na_count(qm)
```

```{r}
#데이터 구조 변경 - 변수명
qm <- qm %>% dplyr::rename_all(tolower) %>% #소문자로 변경
  dplyr::rename(qmr = qmr.score, qr = qr.score) %>%
  dplyr::relocate(qmr)
qm
```


```{r}
#관계 패턴 확인
qm %>%
  ggplot(aes(x = qr, y = qmr)) +
  geom_point(color = sbl) + 
  geom_vline(xintercept = 50, color = lre, linetype = "dotted") +
  theme_bw()

#너트(knot) 정의
qm <- qm %>%
  mutate(knot1 = ifelse(qr - 50 > 0, (qr - 50), 0),
         knot0 = ifelse(qr- 50 > 0 , 1, 0))
qm
```


-   스플라인스 회귀 적합

```{r}
lin_fit <- lm(qmr ~ qr + knot0 + knot1, data = qm)
summary(lin_fit)
```

-   스플라인스 회귀 추정 결과 및 잔차의 확인

```{r}
qm$fit <- fitted(lin_fit)

q1 <- qm %>% 
  ggplot(aes(x = qr, y = qmr, color = as.factor(knot0)),
         show.legend = FALSE
         ) + 
  geom_point(color = sbl) +
  geom_vline(xintercept = 50,
             color = lre,
             linetype = "dotted"
             ) +
  geom_line(aes(x = qr, y = fit, color = as.factor(knot0)),
            show.legend = FALSE
            ) +
  labs(subtitle = "불연속 단일 너트[qr = 50]를 반영한 스플라인스 적합") +
  theme(legend.position = "none") +
  theme_bw()

q2 <- lin_fit %>% 
  ggplot(aes(rstandard(lin_fit))) + 
  geom_histogram(bins = 13, color = "white", fill = sbl) + 
  labs(x = "std residuals", y = "frequency") + 
  theme_bw()

q3 <-lin_fit %>%
  ggplot(aes(fitted(lin_fit), rstandard(lin_fit))) + 
  geom_point(color = sbl) + 
  geom_hline(yintercept = 0,
             color = lre,
             linetype = "dotted"
             ) +
  labs(x = "fitted value", y = "std residuals") +
  theme_bw()

gridExtra::grid.arrange(q1, gridExtra::arrangeGrob(q2, q3, ncol = 2), 
                        nrow = 2) 
```

